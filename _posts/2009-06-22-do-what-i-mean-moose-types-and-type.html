---
title: "Do What I Mean: Moose Types and Type Coercions"
layout: "post"
permalink: "/2009/06/do-what-i-mean-moose-types-and-type.html"
uuid: "556176158814232502"
guid: "tag:blogger.com,1999:blog-903262963771971357.post-556176158814232502"
date: "2009-06-22 19:57:00"
updated: "2009-06-23 01:37:55"
description: 
blogger:
    siteid: "903262963771971357"
    postid: "556176158814232502"
    comments: "2"
categories: [moose, genetic algorithm, 'moosex::types', bioperl, dwim, coercion, perl]
---

<div class="css-full-post-content js-full-post-content">
API's should be simple. I hate it when a module that solves a non-trivial problem requires the user to make non-trivial decisions about every single detail in the domain problem.<br /><br />In my opinion, a class should be smart enough to make all the reasonable assumptions so as to require the least possible amount of input from the user.<br /><br />This might seem a little dangerous, and can certainly be if the approach is taken too far (<a href="http://search.cpan.org/%7Eingy/IO-All-0.39/lib/IO/All.pod">IO::All</a> is for some people an example of too a DWIMmy API), but there's a healthy middle-point in which the user is not only able to rely on the module to solve the problem at hand, but is also spared of most of the cognitive load that solving that problem requires.<br /><br />It is very probable that someone looking for an already-cooked solution in the CPAN is not only not willing to code it up for himself, but also doesn't know enough about the problem to do so (at least not initially). This person is going to rely on the module's wisdom, and the least that it's asked of him, the better.<br /><br />One of the <a href="http://github.com/brunoV/bio-tools-evolver/tree/master">modules that I'm working</a><a href="http://github.com/brunoV/bio-tools-evolver/tree/master"> on</a> deals with protein sequence optimization using genetic algorithms. The user has a collection of protein sequences phylogenetically related, and wants to produce an optimized sequence for a custom trait (solubility, hydrophobicity, digestibility, etc) that still belongs to the original protein family.<br /><br />Under the hood, the algorithm that I implemented requires a <a href="http://en.wikipedia.org/wiki/Multiple_sequence_alignment">multiple protein alignment</a> as input, or profile. Naturally, the methods that do the heavy-lifting expect a <a href="http://search.cpan.org/%7Ecjfields/BioPerl-1.6.0/Bio/SimpleAlign.pm">Bio::SimpleAlign</a> object. But the complication is that protein alignments can come in lots of different formats, many of which are also shared with plain protein, RNA and DNA file formats. Also, the user actually shouldn't be <em>aware</em> that the module requires a protein alignment. Of course it should be allowed to provide one, but if the only thing he has is a bunch of sequences in a flat file, it shouldn't be bothered with opening (how?), parsing (what format? What is its specification?) and aligning (with what algorithm? Gap penalty who?) them to cater to my particular implementation. All he should need to give is a simple filename as a string.<br /><br />So to maximize for user convenience, I decided that the module should accept either of:<br /><ul><li>sequence files of as many formats known,</li><li>alignment files of as many formats possible,</li><li>collection of sequence objects (subclasses of <a href="http://search.cpan.org/%7Ecjfields/BioPerl-1.6.0/examples/root/lib/Bio/Seq.pm">Bio::Seq</a>, also <a href="http://search.cpan.org/%7Ecjfields/BioPerl-1.6.0/Bio/SeqIO.pm">Bio::SeqIO</a> objects), or</li><li>alignment objects (<a href="http://search.cpan.org/%7Ecjfields/BioPerl-1.6.0/Bio/SimpleAlign.pm">Bio::SimpleAlign</a> or <a href="http://search.cpan.org/%7Ecjfields/BioPerl-1.6.0/Bio/AlignIO.pm">Bio::AlignIO</a> objects).</li></ul>In the case that there is ambiguity about whether the user supplied an alignment file or a sequence file (eg., fasta format is both an alignment and a sequence format), I'll make an educated guess and assume that it's an unaligned sequence. In the worst case scenario, It'll just realign an alignment. There is also an extra layer of guessing involved in determining what the format actually is in case that the file has an unknown extension or no extension at all (this is done by <a href="http://search.cpan.org/%7Ecjfields/BioPerl-1.6.0/Bio/Tools/GuessSeqFormat.pm">Bio::Tools::GuessSeqFormat</a>).<br /><br />All of this adds to the simplicity of the API in detriment of the simplicity of the underlying code. Luckily, <a href="http://search.cpan.org/%7Edrolsky/Moose-0.82/lib/Moose.pm">Moose</a> has the tools to make this as straightforward and clean as possible, using Types and Type coercions. The coercion map looks like this:<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_dJsDskOH5ac/Sj_i7sO7d5I/AAAAAAAAABY/jx5pi1w8ZRg/s1600-h/Diagrama1.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 265px; height: 320px;" src="http://3.bp.blogspot.com/_dJsDskOH5ac/Sj_i7sO7d5I/AAAAAAAAABY/jx5pi1w8ZRg/s320/Diagrama1.png" alt="" id="BLOGGER_PHOTO_ID_5350244397453375378" border="0" /></a><br /><br />And the code that implements this is simply the following:<br /><script src="http://gist.github.com/134158.js"></script><br />What's better is that all these types and type coercions are defined separately in a type library that uses <a href="http://search.cpan.org/%7Erkitover/MooseX-Types-0.12/lib/MooseX/Types.pm">MooseX::Types</a>. They deal with both the input sanity checking and the type coercions. This way, not only this complexity is hidden from the user, it's also hidden from the main application. This is really helpful, since now most of the code in the module's main file describes the class behavior and it's not coupled with nor hidden by the juggling of all the possible user input types and input validation code.<br /><br />Now future users of this module (most probably only myself) won't have to check the API's documentation <em>that</em> often; whatever representation of a collection of protein sequences they might have will serve as a valid input. I believe this to be a nice design choice.
</div>

---
title: "Chopping proteins with Moose"
layout: "post"
permalink: "/2009/04/chopping-proteins-with-moose.html"
uuid: "6932851486423035122"
guid: "tag:blogger.com,1999:blog-903262963771971357.post-6932851486423035122"
date: "2009-04-27 13:40:00"
updated: "2009-04-28 00:08:15"
description: 
blogger:
    siteid: "903262963771971357"
    postid: "6932851486423035122"
    comments: "0"
categories: [moose, protein, peptidecutter, protease, perl]
---

<div class="css-full-post-content js-full-post-content">
It comes a time in the life of a wet lab geek when one has to simulate the outcome of a proteolytic degradation of a protein of known sequence (those who said that haven't are lying).<br /><br />So for a problem this common, I did what I always do first: google for an already made solution. Surprisingly, after ten minutes or so, I came out empty-handed.<br /><br />Now don't get me wrong: there <em>were</em> solutions out there, like <a href="http://www.expasy.ch/tools/peptidecutter/">PeptideCutter</a>, <a href="http://pops.csse.monash.edu.au/">PoPS</a>, or <a href="http://emboss.sourceforge.net/">EMBOSS</a>' digest, but none of them were easily usable as a library. The first two only offered a web front-end, and that is OK for a quick digestion of one or two sequences, but I needed batch-processing capabilities and much more flexibility (ie, being able to predict partial digests, for instance). The last one was indeed available as a command line utility, but it offered very few enzyme specificities, it forced an interactive mode, and writing a wrapper for it would have involved more logic that the one implemented in the application (not to mention the ugly reading/writing of temporary files that would have been required to deal with the app's inflexible interface, and that would have created a nice and shiny IO bottleneck in every downstream application that used it).<br /><br />So, there. Homework done, I decided to code for a solution myself. Luckily, <a href="http://www.expasy.ch/tools/peptidecutter/">PeptideCutter</a> had a pretty comprehensive explanation of how their algorithm works, and it is simple enough to be coded quickly.<br /><br />Basically, a protease specificity is modeled as a regular expression that returns true or false on a sequence sliding window. This sliding window is six residues long in <a href="http://www.expasy.ch/tools/peptidecutter/">PeptideCutter</a>, I did it 8 residues long to account for potentially more specific proteases. When the substrate matches the regular expression, the sequence should be cut at the <em>siscile bond</em>. Simple enough.<br /><br />The module is up at my <a href="http://github.com/brunoV/bio-protease/tree/master">github repo</a> (I called it Bio::Protease for a lack of better name), you can download it/fork it/follow it to your liking. It has quite a robust test suite, I checked every single specificity against PeptideCutter's results on the same input.<br /><br />I used Perl and <a href="http://www.iinteractive.com/moose/">Moose</a> for it. One of the things that I like the most about Moose is how easy it is to make really DWIMmy APIs with it.<br />For instance, in Bio::Protease, you can do:<br /><br /><font face="monospace" size=3><font color="#a52a2a"><b>my</b></font>&nbsp;<font color="#005f5f">$protease</font>&nbsp;= Bio::Protease-&gt;<font color="#a52a2a"><b>new</b></font>(<font color="#ff1493">specificity </font>=&gt; <font color="#ff1493">'</font><font color="#ff1493">trypsin</font><font color="#ff1493">'</font>);<br></font><br /><br />This will coerce the string 'trypsin' into an internal representation of the trypsin specificity, which is implemented as a code reference. (Currently, there are more than thirty different specificities to choose from, you can list them by doing <code>say Bio::Protease->Specificities</code>).<br /><br />Also, you could say:<br /><br /><font face="monospace" size=3><font color="#a52a2a"><b>my</b></font>&nbsp;<font color="#005f5f">$cutting_pattern</font>&nbsp;= Bio::Tools::SeqPattern-&gt;<font color="#a52a2a"><b>new</b></font>(<br />&nbsp;&nbsp;&nbsp;&nbsp;-<font color="#ff1493">SEQ </font>=&gt; <font color="#ff1493">'</font><font color="#ff1493">XXXW[^P]RSX</font><font color="#ff1493">'</font>, -<font color="#ff1493">TYPE </font>=&gt; <font color="#ff1493">'</font><font color="#ff1493">Amino</font><font color="#ff1493">'</font><br />);<br /><font color="#a52a2a"><b>my</b></font>&nbsp;<font color="#005f5f">$protease</font>&nbsp;= Bio::Protease-&gt;<font color="#a52a2a"><b>new</b></font>(<font color="#ff1493">specificity </font>=&gt; <font color="#005f5f">$cutting_pattern</font>);<br></font><br /><br />to get a custom regex-based specificity. The one above would cut sequences between the fourth and fifth residues if they match that pattern.<br /><br />You could object that the regex-specificity model is too simplistic for your personal use, and you'd be right. Enzymic cleavage of peptide bonds does not share the deterministic character of restriction enzymes, and sometimes protein's structural characteristics get in the way and play an important part in cleavage. So, to account for an arbitrarily complex specificity model, the 'specificity' attribute also accepts a code reference:<br /><br /><font face="monospace" size=3><font color="#a52a2a"><b>my</b></font>&nbsp;<font color="#005f5f">$nobel_prize_winning_specificity_model</font>&nbsp;=<font color="#005f5f">&nbsp;</font><font color="#a52a2a"><b>sub</b></font><font color="#005f5f">&nbsp;</font>{<br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#a52a2a"><b>my</b></font>&nbsp;<font color="#005f5f">$peptide</font>&nbsp;= <font color="#a52a2a"><b>shift</b></font>;<br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#0000cd"># decide whether to cut $peptide or not</font><br />}<br /><br /><font color="#a52a2a"><b>my</b></font>&nbsp;<font color="#005f5f">$protease</font>&nbsp;= Bio::Protease-&gt;<font color="#a52a2a"><b>new</b></font>(<br />&nbsp;&nbsp;&nbsp;&nbsp;<font color="#ff1493">specificity </font>=&gt; <font color="#005f5f">$nobel_prize_winning_specificity_model</font>;<br />);</font><br /><br />Internally, the module passes a sliding window of peptides to the code reference; if it returns true, it marks the siscile bond as cut.<br /><br />So back to the original problem, to actually make the cuts, you can do:<br /><br /><font face="monospace" size=3><font color="#a52a2a"><b>my</b></font>&nbsp;<font color="#005f5f">@products</font>&nbsp;= <font color="#005f5f">$protease</font>-&gt;digest(<font color="#ff1493">'</font><font color="#ff1493">MAAEEELLKKVVIKP</font><font color="#ff1493">'</font>); </font><br /><br />The products of a full digestion of the argument sequence will be returned as a list. On the other hand, if you want to get the siscile bonds, you'd say:<br /><br /><font face="monospace" size=3><font color="#a52a2a"><b>my</b></font>&nbsp;<font color="#005f5f">@cut_sites</font>&nbsp;= <font color="#005f5f">$protease</font>-&gt;cleavage_sites(<font color="#005f5f">$seq</font>);</font><br /><br />And, for partial digests, you can use the method 'cut', that will return the products of a single cleavage if you provide a siscile bond as an argument:<br /><br /><font face="monospace" size=3><font color="#a52a2a"><b>my</b></font>&nbsp;<font color="#005f5f">@products</font>&nbsp;= <font color="#005f5f">$protease</font>-&gt;cut(<font color="#005f5f">$seq</font>, <font color="#005f5f">$cut_sites</font>[<font color="#a52a2a"><b>rand</b></font>&nbsp;<font color="#005f5f">@cut_sites</font>]);</font><br /><br />In the above expression, <code>$cut_sites[rand @cut_sites]</code> will choose a random cleavage site from <code>@cut_sites</code>, and cut <code>$seq</code> there. This is the basis for a bigger module (and the reason for coding this one), which could make it to a separate blog post in the future.<br /><br />The take home lesson is: use <a href="http://www.iinteractive.com/moose/">Moose</a>. I am too lazy to have done all of this had not been so easy. Without it, I would have probably whipped up a half-assed script (not a shiny, reusable module) that took a sequence and a specificity as input from the command line, and that barfed a table with the cleavage sites as output, and not much more (sounds familiar?). But all of the above functionality was implemented in a hundred-or-so lines of clean, declarative, object-oriented code, and I don't ever have to worry about this problem again (and neither do you).
</div>
